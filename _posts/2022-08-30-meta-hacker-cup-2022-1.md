---
layout: post
title:  "Qualifi√© en 24e place de la Meta Hacker Cup, voici mes solutions"
date:   2022-08-30 10:49:56 +0200
image:  '/images/blog/meta-hacker-cup-2022-1/header.png'
tags:   [Algo, Comp√©titions]
---

Hier, je me suis class√© **24e mondial** sur la Meta Hacker Cup, une comp√©tition de code r√©unissant plus de 27 000 participants !

Dans cet article, j'ai envie de vous expliquer comment j'ai r√©solu les 6 √©preuves en moins de 2h. Vous allez voir, c'est pas si compliqu√©. 

Commen√ßons par un peu de contexte.

**Facebook** (d√©sormais Meta) organise chaque ann√©e l'un des plus grands championnats de programmation au monde, qui leur sert notamment √† rep√©rer et recruter des d√©veloppeurs¬∑es d'√©lite.

La Hacker Cup est organis√©e en 5 rounds de s√©lection. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535887261827072-FbZVZoWXEAIRI9R.jpg" draggable="false">
  </div>
</div>

Un probl√®me d'algorithmique est quasiment toujours structur√© de la m√™me mani√®re.

On nous donne un √©nonc√© tr√®s pr√©cis du probl√®me √† r√©soudre, ainsi que des contraintes sur les grandeurs des donn√©es √† traiter (par exemple "la liste comporte entre 1 et 1000 √©l√©ments").

L'objectif est de coder un programme dans le langage de son choix (pour les comp√©titions j'adore Python) qui va prendre en entr√©e un jeu de donn√©es et produire en sortie la bonne r√©ponse.

Notre code est ensuite test√© sur des **dizaines d'exemples** pour v√©rifier qu'il est correct. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535894887043074-FbZWKrEXgAEzWPU.jpg" draggable="false">
  </div>
</div>

Le round de qualification de cette ann√©e comportait **6 √©preuves**, chacune rapportant un certain nombre de points.

Ici, les points n'avaient pas d'importance (il suffit de valider au moins un exo pour se qualifier) mais ils sont cruciaux pour le classement des rounds suivants.

Pour chacun des exercices, je vais vous expliquer mon anayse et ma mani√®re de r√©soudre le probl√®me. Pour commencer, le probl√®me le plus facile de cette ann√©e, intitul√© Second Hands. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535902382313475-FbZWUNLXwAEyCqz.jpg" draggable="false">
  </div>
</div>

On dispose de deux vitrines contenant chacune K socles, et on a N objets √† afficher dans celles-ci.

Pour des raisons esth√©tiques, chaque vitrine ne peut pas contenir deux objets identiques. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535907247603713-FbZWbBpXkAErlFm.jpg" draggable="false">
  </div>
</div>

On cherche √† savoir s'il existe une configuration qui permet d'afficher tous les objets en vitrine et qui respecte cette contrainte. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535913040027650-FbZWwhdWYAAJuCx.jpg" draggable="false">
  </div>
</div>

Pour commencer, on peut rapidement se rendre compte que s'il y a plus d'objets que de socles dans les vitrines (N &gt; 2*K) alors on n'arrivera pas √† tout faire rentrer.

√áa peut para√Ætre √©vident, mais on peut facilement perdre des points en oubliant de v√©rifier cette condition !

L'autre v√©rification √† effectuer concerne les diff√©rents types d'objets :

- Si un objet est pr√©sent en un seul exemplaire, il peut aller dans n'importe quelle vitrine.
- Avec deux exemplaires, on doit en mettre un dans chaque vitrine.
- Au-del√† de 3, c'est impossible.

Si on a suffisamment de place dans les vitrines (condition 1) et que les groupes d'objets identiques n'ont jamais plus de 2 exemplaires (condition 2), alors il existe forc√©ment un agencement des objets qui fonctionnera.

Cet exo se r√©sout donc en quelques lignes : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535922435178496-FbZXC8dXgAEcEk1.jpg" draggable="false">
  </div>
</div>

Pour l'exercice B intitul√© "Second Friend", on va devoir planter des arbres. Cet exercice est s√©par√© en deux sous-probl√®mes (B1 et B2) de difficult√© croissante que l'on peut r√©soudre ind√©pendamment.

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535927560617985-FbZXM1zWIAMR8pc.jpg" draggable="false">
  </div>
</div>

Le principe du sous-probl√®me B1 est simple : on a des arbres plant√©s sur une grille de forme rectangulaire. 

Notre objectif est d'en planter d'autres pour que chaque arbre de la grille finale ait au moins deux voisins (diagonales exclues) : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535933013196800-FbZXV4YWYAAzXLN.jpg" draggable="false">
  </div>
</div>

Ici, on a de la chance sur l'√©nonc√© : il est demand√© de renvoyer n'importe quelle solution valide, sans contrainte sur le nombre d'arbres plant√©s.

Du coup, il existe une solution assez √©vidente : on plante des arbres PARTOUT. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535938939863041-FbZXaOvXwAE3Voz.jpg" draggable="false">
  </div>
</div>

En effet, chaque arbre aura un nombre satisfaisant de voisins avec cette solution :

- Les coins ont 2 voisins
- Les bords en ont 3
- Tous les autres en ont 4

Mais en fait, cette solution ne marche pas toujours.

Est-ce que vous arrivez √† trouver un **cas particulier** qui peut servir de contre-exemple ?

Effectivement, si la grille est trop petite alors √ßa va coincer : certaines cellules n'auront qu'un seul voisin !

Il faut donc bien pr√™ter attention aux contraintes fournies dans l'√©nonc√©, qui indiquaient que la largeur et la hauteur minimale de la grille √©taient de 1. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535948397928450-FbZXyhRX0AEUN59.jpg" draggable="false">
  </div>
</div>

Et on a d'ailleurs un contre-exemple dans ce contre-exemple !

Si la grille a une largeur et/ou hauteur √©gale √† 1 mais qu'aucun arbre n'est pr√©sent initialement, il suffit de n'en planter aucun ;) 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535953590460417-FbZX9FoXkAMxcf0.jpg" draggable="false">
  </div>
</div>

En tout, √ßa nous fait donc trois cas possibles √† v√©rifier :

1. Si aucun arbre pr√©sent initialement : la solution est un **champ vide**
2. Si la largeur ou la hauteur sont √©gales √† 1 : **pas de solution**
3. Dans tous les autres cas, la solution est un champ **enti√®rement rempli** d'arbres 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535959194140672-FbZYRKvXgAAtnFl.jpg" draggable="false">
  </div>
</div>

Passons maintenant √† l'exercice B2, qui est la suite du pr√©c√©dent.

Le principe est ici le m√™me, en ajoutant un √©l√©ment perturbateur : des pierres sont pr√©sentes sur la grille et nous emp√™chent de planter des arbres sur certains emplacements. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535964910903297-FbZYatdWQAAJcRE.jpg" draggable="false">
  </div>
</div>

Pour r√©soudre ce challenge, il va falloir cr√©er un algorithme plus intelligent que pour le sous-probl√®me B1.

En effet, placer un arbre dans chaque emplacement disponible risque de cr√©er des solutions invalides : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535970233565187-FbZYjGVWIAAgQUH.jpg" draggable="false">
  </div>
</div>

Ce qui pose probl√®me, ce sont les pierres qui vont cr√©er des impasses √©troites dans lesquelles aucun arbre ne pourra √™tre pr√©sent.

Dans cet exemple, on peut cr√©er un premier "chemin" d'arbres valide sur les cases marqu√©es d'un point jaune, qui ont chacune au moins deux voisins. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535974788464641-FbZYptAWIAU6Gob.jpg" draggable="false">
  </div>
</div>

Mais pour ajouter un second voisin √† notre arbre plac√© initialement, il va aussi falloir en ajouter successivement sur ce chemin, qui se termine par un cul-de-sac ayant un seul voisin possible.

Cette configuration initiale n'admet donc pas de solution. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535980014637056-FbZYvANXwAAbRKI.jpg" draggable="false">
  </div>
</div>

Ce qu'il faut donc remarquer pour r√©soudre ce probl√®me, c'est que certains emplacements sont interdits : c'est l√† o√π il n'existe qu'un seul voisin potentiel. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535985014247426-FbZY2duXoAIGrA9.jpg" draggable="false">
  </div>
</div>

En marquant ces cases interdites, on se rend compte que √ßa cr√©e de nouveaux emplacements n'ayant √† leur tour qu'un seul voisin potentiel : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564535989917335554-FbZY617WYAEXUkg.jpg" draggable="false">
  </div>
</div>

On peut ainsi propager cet ensemble pour d√©terminer tous les emplacements sur lesquels aucune solution valide ne comportera d'arbres.

√Ä la fin de ce processus, toutes les cases n'ayant pas √©t√© marqu√©es comptent au moins deux voisins et on peut placer un arbre dessus ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539518060986369-FbZZVVPWAAAWS9_.jpg" draggable="false">
  </div>
</div>

Si un arbre √©tait initialement plac√© sur une cellule interdite, alors aucune solution n'existe.

Sinon, il suffit de planter un arbre sur chaque emplacement non marqu√© et √ßa nous donne une configuration valide üôÇ

Pour r√©soudre ce probl√®me de propagation efficacement, on peut utiliser un algorithme de recherche en largeur, souvent appel√© **BFS** (pour "Breadth-First Search").

Je vous √©pargne les d√©tails d'impl√©mentation, mais  vous pouvez lire ci-dessous ma solution telle que je l'ai cod√©e pendant l'√©preuve, sans retouche (attention, code tr√®s sale).

D'apr√®s les logs, j'ai mis 29 minutes entre l'ouverture de l'√©nonc√© et la derni√®re ligne de code ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539526302892032-FbZZkNdWQAAUMKn.jpg" draggable="false">
  </div>
</div>

Passons √† l'exercice C, que j'ai √©tonnamment trouv√© plus facile que le B alors qu'il rapportait plus de points. C'est parti pour "Second Meaning" !

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539530954276865-FbZZrdKXEAAoDt0.jpg" draggable="false">
  </div>
</div>

(Oui, tous les titres d'exos commencent par "Second", c'√©tait le th√®me de ce round) 

Ce probl√®me est bas√© sur l'ambigu√Øt√© du d√©codage en morse si on retire les espaces. Prenons par exemple la cha√Æne ‚Ä¢--‚Ä¢‚Ä¢-‚Ä¢-‚Ä¢‚Ä¢ :

- En l'interpr√©tant comme `‚Ä¢  --‚Ä¢  ‚Ä¢-  ‚Ä¢-‚Ä¢‚Ä¢`, on obtient le mot EGAL
- En l'interpr√©tant comme `‚Ä¢--  ‚Ä¢‚Ä¢  -‚Ä¢  -‚Ä¢‚Ä¢`, on obtient le mot WIND

Dans cet exercice, il faut **cr√©er un nouvel alphabet morse**, de telle sorte qu'il n'existe aucune cha√Æne de points et de tirets qui admette plusieurs d√©codages possibles.

Le premier symbole de cet alphabet nous est impos√©, et il faut inventer les autres.

Par exemple, si on nous demande un alphabet de 4 lettres avec le symbole --‚Ä¢ impos√©, on peut proposer l'alphabet ci-dessous.

Comme tous les symboles font 3 caract√®res, le d√©codage d'une cha√Æne consiste √† d√©coder chaque bloc de 3 caract√®res successivement. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539538533498886-FbZaLMzWQAI55aZ.jpg" draggable="false">
  </div>
</div>

Prenons maintenant un cas plus difficile : on nous demande un autre alphabet de 4 lettres, cette fois-ci avec ‚Ä¢ comme premier symbole.

Pas possible cette fois de cr√©er 4 lettres diff√©rentes ayant toutes la m√™me longueur, mais on peut quand m√™me trouver une solution. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539543478493184-FbZaT0cWYAEmR-j.jpg" draggable="false">
  </div>
</div>

Un alphabet qui respecte la propri√©t√© demand√©e est appel√© "code pr√©fixe" : aucun de ses symboles n'est le pr√©fixe d'un autre.

Ainsi, le symbole ‚Ä¢‚Ä¢-‚Ä¢ peut cohabiter avec ‚Ä¢‚Ä¢-- et - dans un alphabet, mais pas avec ‚Ä¢‚Ä¢ ni ‚Ä¢‚Ä¢-‚Ä¢--

Les formes les plus connues de code pr√©fixe sont la compression de Huffman et les caract√®res UTF-8, et c'est aussi le cas des indicatifs t√©l√©phoniques internationaux ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539549476392960-FbZalwtWYAEM8J3.jpg" draggable="false">
  </div>
</div>

Les contraintes de l'√©nonc√© nous disent que la taille demand√©e pour l'alphabet est comprise entre 2 et 100. Chaque symbole peut contenir entre 1 et 200 caract√®res.

Le sous-probl√®me C2 est identique, √† l'exception de ce nombre maximal de caract√®res par symbole qui est de 10.

La premi√®re solution que j'ai trouv√©e permet de r√©soudre directement les deux sous-probl√®mes, ce qui m'a permis de gagner un peu de temps.

On va cr√©er un alphabet o√π toutes les lettres (sauf la premi√®re qu'on ne choisit pas) vont faire exactement 10 caract√®res de long.

Il existe **2^10 = 1024 symboles en morse de longueur 10**. Aucun n'est le pr√©fixe d'un autre comme ils sont distincts et font la m√™me longueur, donc on peut g√©n√©rer un code pr√©fixe compos√© de 1024 symboles.

Le premier code de l'alphabet nous est impos√©, mais √ßa ne pose pas vraiment de probl√®me : il suffit d'√©liminer de notre code tous les symboles incompatibles. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539558586470400-FbZa1lMX0AEjS7b.jpg" draggable="false">
  </div>
</div>

**Dans le pire cas**, le symbole impos√© contient un seul caract√®re (‚Ä¢ ou -), et √©limine **la moiti√©** des symboles de notre alphabet potentiel.

Mais les 512 qui nous restent suffisent largement comme la taille maximale de l'alphabet demand√© est de 100.

Et voici le code de ma solution, avec itertools qui nous permet de g√©n√©rer tous les symboles en une ligne au lieu de s'emb√™ter avec 10 boucles imbriqu√©es ou des bitmasks. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539564777213952-FbZbDwuWYAE_kgG.jpg" draggable="false">
  </div>
</div>

Le dernier probl√®me, intitul√© "Second Flight" √©tait le plus difficile de cette √©preuve de qualification. Il s'agissait de calculer des capacit√©s de flux de voyageurs entre deux destinations sur un r√©seau a√©rien. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539569806233601-FbZbLM0WAAA0hW8.jpg" draggable="false">
  </div>
</div>

On a plusieurs a√©roports reli√©s par des lignes a√©riennes. Chaque ligne est desservie **deux fois par jour (matin et soir)** dans les deux sens, par des avions de capacit√© donn√©e.

Il faut calculer le nombre maximal de passagers par jour pouvant aller entre deux destinations donn√©es. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539574671532032-FbZbfrZXkAEQ9I_.jpg" draggable="false">
  </div>
</div>

Les algorithmiciens auront d√©j√† reconnu une variante du probl√®me de flot maximal dans un DAG et d√©gain√© l'artillerie lourde avec l'algorithme d'Edmonds-Karp ou de Dinic.

En fait, cette solution est incorrecte car trop lente, et il existe plus simple.

L'√©nonc√© nous dit qu'on peut avoir jusqu'√† 200 000 a√©roports et 200 000 lignes a√©riennes dans notre r√©seau a√©rien.

En plus de √ßa, on doit pouvoir traiter jusqu'√† 200 000 calculs de capacit√©s entre diff√©rentes paires d'a√©roports. On va donc devoir bien optimiser l'algo.

Pour aller d'une ville A vers une autre ville B, un passager a **trois options** :

- Prendre le vol A-&gt;B du matin
- Prendre le vol A-&gt;B du soir
- Faire escale dans une tierce ville X : prendre le vol A-&gt;X le matin et X-&gt;B le soir 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539582812758016-FbZcCiZXgAA7skm.jpg" draggable="false">
  </div>
</div>

Pour conna√Ætre la capacit√© maximale journali√®re entre deux villes, il faut donc compter deux fois la capacit√© du trajet A-&gt;B, puis la capacit√© de chaque trajet avec escale (√©gale √† la plus petite capacit√© des deux vols qui la composent). 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564539587464159232-FbZcJfoWYAEJBYu.jpg" draggable="false">
  </div>
</div>

La complexit√© de cette fonction est O(N) car on parcourt l'ensemble des villes dans une boucle.

En multipliant √ßa par 200 000 requ√™tes, on se rend compte qu'il faudrait plusieurs minutes pour traiter chaque jeu de test, ce qui est trop lent.

Voyons comment am√©liorer √ßa.

La premi√®re optimisation consiste √† ne pas parcourir toutes les villes, mais seulement besoin de celles qui sont reli√©es √† A et √† B : les autres ont de toute fa√ßon une capacit√© de 0.

Trouver les villes en question revient √† faire un calcul d'intersection entre deux ensembles.

Pour ce calcul, on regarde laquelle ville a le moins de lignes a√©riennes, et on it√®re sur celles-ci.

La complexit√© du calcul est O(min(nA, nB)), avec nA et nB le nombre de villes reli√©es √† A et B respectivement. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564541551186944005-FbZc2VVWAAMNgF7.jpg" draggable="false">
  </div>
</div>

Alors c'est vrai, il est possible que A et B soient chacune reli√©es √† un tr√®s grand nombre de villes, auquel cas l'optimisation pr√©c√©dente ne permet pas d'acc√©l√©rer le calcul.

Cependant, l'√©nonc√© nous indique qu'il n'y a pas plus de 200 000 lignes a√©riennes en tout.

Sachant qu'entre 200 000 a√©roports il existe plus de 19 milliards de lignes a√©riennes possibles, la limitation du nombre effectif de lignes utilis√©es nous permet de d√©couvrir une propri√©t√© int√©ressante du graphe.

Intuitivement, on peut voir que m√™me si certaines paires peuvent avoir un calcul assez lent (car A et B sont toutes les deux reli√©es √† un grand nombre de villes), ces paires sont forc√©ment **en nombre limit√©**. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564541558736707584-FbZdEaLWIAIaXQr.jpg" draggable="false">
  </div>
</div>

Si A et B sont chacune reli√©es √† 100 000 villes, alors toutes les lignes a√©riennes sont allou√©es et chaque autre ville n'est reli√©e qu'√† A et B. Le calcul de n'importe quelle autre paire sera donc **quasi instantan√©** gr√¢ce √† la complexit√© O(min(nA, nB)) √©tablie plus t√¥t.

Il reste un pi√®ge : m√™me s'il existe un faible nombre de requ√™tes "lentes" possibles, qu'est-ce qui les emp√™che de nous faire calculer plein de fois la m√™me route lente ? En r√©alit√©, ce n'est pas un probl√®me.

Comme une m√™me requ√™te aura toujours le m√™me r√©sultat, il nous suffit de **sauvegarder** tous les r√©sultats pr√©c√©dents.

Ainsi, on n'aura pas √† refaire le calcul au cas o√π une demande soit r√©p√©t√©e plusieurs fois. √áa s'appelle la **m√©mo√Øsation**, et c'est trivial √† impl√©menter en Python ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564541565980344320-FbZdOOhWYAAj8sU.jpg" draggable="false">
  </div>
</div>

Ce thread est termin√©, j'esp√®re que ce corrig√© vous a plu üòÑ

L'explication du dernier probl√®me est bien touffue malgr√© la solution simple en apparence, bravo d'avoir tenu jusqu'au bout ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-1/1564541570539479042-FbZdXogWYAYhFew.jpg" draggable="false">
  </div>
</div>

Si vous voulez continuer √† am√©liorer votre niveau en algo, je poste chaque semaine un petit challenge et sa correction pour s'entra√Æner aux entretiens d'embauche, que vous retrouverez dans [cet article](/blog/preparation-entretiens-tech).

Si vous avez l'oeil, vous aurez peut-√™tre remarqu√© que plusieurs images de ce thread ont √©t√© g√©n√©r√©es par l'intelligence artificielle Midjourney.

Pour comprendre comment ces mod√®les fonctionnent, retrouvez les explications techniques dans mon [dernier article](/blog/fonctionnement-dall-e-2) !
