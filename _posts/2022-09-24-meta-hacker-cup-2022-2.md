---
layout: post
title:  "Nouveau top 100 mondial sur la Meta Hacker Cup - mes solutions"
date:   2022-09-24 18:44:34 +0200
image:  '/images/blog/meta-hacker-cup-2022-2/header.png'
tags:   [Algo, Comp√©titions]
---

Sur le deuxi√®me round du challenge Meta Hacker Cup, je me suis √† nouveau class√© dans le top 100 mondial !

Aujourd'hui, je vous pr√©sente les solutions aux 4 exercices de code comme je l'avais fait pour le round de qualification.

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715030197018627-FdbzTWZWAA4kLTp.jpg" draggable="false">
  </div>
</div>

N'√©tant pas tout √† fait d'accord avec les notes de difficult√© attribu√©es par les organisateurs de Facebook, je vais pr√©senter mes corrig√©s dans un ordre assez sp√©cial : on va commencer tranquillement avec le A1, puis je laisse le A2 de c√¥t√© pour y revenir √† la fin de cet article. 

On nous donne un paquet de cartes, num√©rot√©es de 1 √† N sans doublons. L'objectif est de d√©terminer s'il est possible d'effectuer **exactement K coupes** du paquet pour parvenir √† un ordre qui nous est fourni.

Pour rappel, une coupe d'un paquet de cartes, c'est √ßa : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715035859439616-FdbzncuXgAAxXpc.jpg" draggable="false">
  </div>
</div>

Prenons un exemple : on nous demande de passer de l'ordre [4, 1, 5, 3, 2] √† [3, 2, 4, 1, 5] avec exactement deux coupes.

Il existe effectivement une solution que voici : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715041760722944-FdbzsukWYAUh-Hc.jpg" draggable="false">
  </div>
</div>

En revanche, passer de l'ordre [1, 2, 3, 4] √† [4, 3, 2, 1] en 3 coupes est impossible.

En comp√©tition de code, c'est toujours bien d'avoir des gadgets (cartes, d√©s, ciseaux) √† port√©e de main en plus de son carnet de brouillons, pour comprendre plus facilement ce genre d'exos üòÅ 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715046953353216-FdbzzyzXgAcM-F4.jpg" draggable="false">
  </div>
</div>

Apr√®s avoir compris l'√©nonc√© et jou√© avec les cas d'exemple, la deuxi√®me √©tape de la r√©solution d'un probl√®me algorithmique est de chercher des propri√©t√©s int√©ressantes pouvant nous permettre de simplifier sa mod√©lisation.

En continuant √† jouer avec les cartes, on peut constater deux choses li√©es aux coupes.

Premi√®rement, on remarque qu'une coupe m√©lange tr√®s mal le paquet : en consid√©rant que le paquet forme une boucle o√π la premi√®re et la derni√®re carte sont voisines, **l'ordre ne change jamais** ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715053618102276-Fdbz_SMWYAAvX4i.jpg" draggable="false">
  </div>
</div>

L'autre propri√©t√© remarquable est que plusieurs coupes successives (ici 2 cartes puis 1 carte) peuvent √™tre r√©alis√©es en une seule coupe (ici 3 cartes).

De m√™me, on peut diviser une coupe de X cartes en plusieurs coupes, tant que leur somme (modulo N) est √©gale √† X. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715059280330755-Fdb0DIoXoAA_eBq.jpg" draggable="false">
  </div>
</div>

Le nombre de coupes impos√© n'est donc pas important, car on peut les fusionner ou diviser √† volont√© pour obtenir le nombre d'actions d√©sir√©. √Ä quelques exceptions pr√®s, on peut donc ignorer la valeur de K : il faut seulement d√©terminer si le m√©lange est r√©alisable en une coupe.

Pour savoir s'il est possible de passer d'un ordre √† l'autre, il faut donc d√©terminer s'ils sont √©quivalents. On a vu qu'une coupe ne peut pas modifier fondamentalement l'ordre circulaire des cartes, elle ne fait que **d√©placer l'emplacement de la fin du paquet**.

On sait donc qu'il est possible de passer d'un paquet √† l'autre lorsque leurs cartes sont pr√©sentes dans le m√™me ordre circulaire.

Pour d√©terminer √ßa algorithmiquement, il suffit de calculer l'ordre √† partir de la carte 1 et voir s'il est identique entre les deux paquets ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715067811635202-Fdb0N5oWIAE4JTU.jpg" draggable="false">
  </div>
</div>

Le code de v√©rification en Python est tout simple, on utilise l'op√©rateur de slicing pour mettre la valeur 1 en premier dans chaque liste. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715073549406208-Fdb0SAkWYAUr9Id.jpg" draggable="false">
  </div>
</div>

Il reste n√©anmoins quelques cas particuliers √† traiter, le moindre oubli pouvant √™tre tr√®s co√ªteux sur cette comp√©tition : si on donne la moindre r√©ponse incorrecte parmi les 80 tests, c'est 0 points.

Et en plus de √ßa, on n'a le droit qu'√† une unique soumission !

On a trois cas particuliers pour lesquels le code ci-dessus donne une mauvaise r√©ponse. Voici des contre-exemples qui correspondent :

- [1, 2, 3] -&gt; [2, 3, 1] en 0 coupe
- [1, 2, 3] -&gt; [1, 2, 3] en 1 coupe
- Je vous laisse trouver le dernier üòâ (indice : 2 cartes)

On reviendra plus tard √† la deuxi√®me moiti√© de ce probl√®me, o√π chaque carte peut √™tre pr√©sente en plusieurs exemplaires.

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715084630695938-Fdb0edHX0AEgf9c.jpg" draggable="false">
  </div>
</div>

Dans le deuxi√®me exercice, on nous fournit un plan o√π figurent des puits et des plantes. L'objectif est de calculer un "**score d'irrigation**". 

Le calcul de ce score est simple : pour chaque paire puits/plante, on va calculer le **carr√© de la distance** qui les s√©pare. Le score correspond √† la somme de tous ces carr√©s. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715089668071425-Fdb0jW9XwAERhqh.jpg" draggable="false">
  </div>
</div>

Par exemple ici, nos 4 paires ont des distances respectives de 6, ‚àö29, ‚àö10 et ‚àö13 (obtenues gr√¢ce au th√©or√®me de Pythagore).

En additionnant les carr√©s de ces distances, on obtient donc 36+29+10+13, soit un score de 88 qui sera la r√©ponse au probl√®me. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715095489748997-Fdb0kogX0AESPhD.jpg" draggable="false">
  </div>
</div>

Alors ce probl√®me, il a l'air vraiment tr√®s simple : **deux boucles** pour it√©rer sur les arbres et les puits, un calcul des distances et c'est r√©gl√© ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715101043023873-Fdb1AtCXEAEj6KP.jpg" draggable="false">
  </div>
</div>

En faisant √ßa, on va rapidement √™tre confront√©s √† un probl√®me de **performance** : l'√©nonc√© nous informe qu'il est possible d'avoir jusqu'√† 500.000 arbres et 500.000 puits. 

Avec sa complexit√© de O(N¬≤), l'algorithme na√Øf prendrait plusieurs heures pour ce calcul üòñ

Il va nous falloir trouver une optimisation qui permet de faire le calcul de score en quelques millisecondes. 

Ici, l'astuce va √™tre purement math√©matique : certaines op√©rations sont r√©p√©t√©es un grand nombre de fois dans l'algorithme pr√©c√©dent, et on va pouvoir les condenser.

Accrochez-vous un peu sur les 3 prochaines minutes, la notation math√©matique peut faire peur mais c'est du niveau terminale (et au pire vous skippez, c'est pas tr√®s grave).

On va d'abord calculer le score entre UN SEUL puits et toutes les plantes, avec la formule de Pythagore : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715109628755969-Fdb1N0ZXoAMmCHL.jpg" draggable="false">
  </div>
</div>

La premi√®re simplification que l'on peut faire, c'est d'√©liminer le combo carr√© + racine carr√©e qui s'√©liminent mutuellement.

Avec √ßa, on peut voir que les deux composantes X et Y peuvent √™tre calcul√©es ind√©pendamment. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715115614019584-Fdb1RY3XgAAh3DI.jpg" draggable="false">
  </div>
</div>

Pour simplifier la suite, on va garder uniquement le calcul du score sur la composante X, le score selon Y sera calcul√© pareil.

Gr√¢ce √† l'identit√© remarquable (a-b)¬≤ = a¬≤ - 2ab + b¬≤, on peut d√©velopper la formule : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715121297362947-Fdb1VPfXoAAWwEb.jpg" draggable="false">
  </div>
</div>

Ici encore, on peut s√©parer cette somme en trois sommes ind√©pendantes : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715126259253251-Fdb1YJIXwAMPGYA.jpg" draggable="false">
  </div>
</div>

Et enfin, la derni√®re √©tape de notre optimisation, celle qui va d√©corr√©ler les puits et les plantes dans notre calcul.

On rappelle ici qu'on est en train de calculer le score pour un seul puits, la valeur Xpuits est donc une constante dans notre formule. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573715131351040000-Fdb1bqbWQAgnrfK.jpg" draggable="false">
  </div>
</div>

Mais il nous reste un gros probl√®me : la formule contient encore des sommes, donc le calcul de chaque puits doit parcourir la liste de toutes les plantes !

En r√©alit√© non, car ces deux sommes sont les m√™mes pour chaque puits. On peut donc les pr√©calculer une fois pour toutes. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716420898201606-Fdb1pOVWYAEz9Tz.jpg" draggable="false">
  </div>
</div>

On peut donc maintenant calculer le score d'un puits avec une complexit√© O(1) alors qu'elle √©tait O(N) pr√©c√©demment, ce qui nous permet de calculer le score total des N puits en complexit√© O(N) au lieu de O(N¬≤) üòÅ

Voici le code : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716426090844160-Fdb1tqPXgAIGyfl.jpg" draggable="false">
  </div>
</div>

Revenons maintenant √† la deuxi√®me moiti√© du probl√®me A (celui avec les jeux de cartes), que j'ai d√©cid√© de traiter en dernier car il fait appel √† une notion d'algorithmique avanc√©e. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716430759116800-Fdb12TOXgAAorz5.jpg" draggable="false">
  </div>
</div>

Souvenez-vous de l'exercice A1, pour savoir s'il est possible de passer d'un deck √† l'autre il suffisait de d√©terminer si les cartes √©taient dans le m√™me ordre circulaire entre le d√©part et l'arriv√©e. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716434936545281-Fdb16jhX0AIJeCt.jpg" draggable="false">
  </div>
</div>

Ici c'est exactement la m√™me chose, mais les cartes peuvent appara√Ætre **plusieurs fois**. Notre normalisation qui remet la carte 1 au d√©but de la liste ne marche plus !

Prenons cet exemple o√π le code donnera une mauvaise r√©ponse (les decks sont bien dans le m√™me ordre) : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716439621664769-Fdb1986WAAAzKxU.jpg" draggable="false">
  </div>
</div>

On peut essayer de corriger notre algo de normalisation pour g√©rer le cas o√π on a plusieurs cartes 1, mais on se retrouvera toujours dans des impasses o√π le code est soit incorrect, soit trop lent.

Pour v√©rifier si deux ordres circulaires sont identiques, au lieu d'essayer de les normaliser on peut simplement **essayer les N rotations possibles** et voir si on trouve une correspondance.

Cet algorithme est correct mais **trop lent**. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716446294728704-Fdb2FhNXwAIz2MV.jpg" draggable="false">
  </div>
</div>

Mais on peut en r√©alit√© acc√©l√©rer la comparaison. Imaginons qu'il existe une fonction de hachage capable de condenser un tableau en une valeur unique.

Au lieu de comparer tous les ordres possibles, il suffirait de comparer leurs hashs : 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716450765930496-Fdb2K2PXgAAezug.jpg" draggable="false">
  </div>
</div>

Le souci, c'est qu'une fonction de hachage doit forc√©ment prendre en compte les N √©l√©ments de la liste, ce qui est incompatible avec la complexit√© O(1) d√©sir√©e pour son calcul.

En fait, c'est tout √† fait possible avec un peu d'astuce !

Consid√©rons que notre calcul de hash prenne la forme suivante, en se basant sur les puissances d'un nombre, prenons ici 31 pour l'exemple (fun fact : c'est exactement comme √ßa que fonctionne hashCode en Java) 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716457816571905-Fdb2TdeWAAY4U4G.jpg" draggable="false">
  </div>
</div>

Si on souhaite ajouter un √©l√©ment √† la fin de notre liste, il n'est pas n√©cessaire de tout recalculer : la diff√©rence entre les deux hashs d√©pendra seulement de la valeur du nouvel √©l√©ment et de la taille du tableau. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716462983856130-Fdb2bCyX0AE0dOd.jpg" draggable="false">
  </div>
</div>

Pour retirer le premier √©l√©ment, pareil : on soustrait sa valeur au hash puis on divise par 31, ce qui permet de recalculer le hash sans reparcourir toute la liste. 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716468532973569-Fdb2b_ZX0AQ0UYD.jpg" draggable="false">
  </div>
</div>

En faisant ces deux op√©rations successivement, vous voyez qu'on a r√©ussi √† calculer le hash de [1, 2, 1, 3, 3] √† partir de celui de [3, 1, 2, 1, 3] **avec une complexit√© O(1)**. En r√©p√©tant l'op√©ration, on peut calculer les hashs de toutes les rotations tr√®s rapidement ! 

<div class="gallery-box">
  <div class="gallery">
  <img src="/images/blog/meta-hacker-cup-2022-2/1573716473499058177-Fdb2iNOXoAAcOv6.jpg" draggable="false">
  </div>
</div>

Il restait sur ce round un probl√®me tr√®s difficile que je n'ai pas pu r√©soudre, mais comme tr√®s peu de personnes l'ont valid√© je suis quand m√™me class√© 90e mondial üòÅ

Le prochain round commence dans quelques minutes et dure jusque 22 heures, vous pouvez suivre ma progression [ici](https://www.facebook.com/codingcompetitions/hacker-cup/2022/round-2/scoreboard).

Je dois terminer dans le **top 2000** pour recevoir le T-shirt de cette √©dition, et top 500 pour me qualifier au prochain !

Et pour retrouver le post pr√©c√©dent qui portait sur le round de qualification, c'est [par ici](/blog/meta-hacker-cup-2022-1).

Comme d'habitude, n'h√©sitez pas √† partager mon travail si √ßa vous a plu, qu'un article comme celui-ci me prend environ 2 jours de travail entre l'√©criture et les illustrations.

Update : jme suis fait d√©truire sur le round 3, 1312e üò≠

J'√©tais vraiment pas loin de d√©crocher le top 500 mais il m'a manqu√© une optim et un debug pour quadrupler mon score. On se contentera du t-shirt, √† l'ann√©e prochaine !

